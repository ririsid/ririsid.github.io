<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Optional Unwrapping"/><link rel="canonical" href="https://ririsid.github.io/posts/2015-07-07-the-swift-programming-language-swift-2-prerelease-strings-and-characters-digest"/><meta name="twitter:url" content="https://ririsid.github.io/posts/2015-07-07-the-swift-programming-language-swift-2-prerelease-strings-and-characters-digest"/><meta property="og:url" content="https://ririsid.github.io/posts/2015-07-07-the-swift-programming-language-swift-2-prerelease-strings-and-characters-digest"/><title>Swift 프로그래밍 언어 - 문자열과 문자 | Optional Unwrapping</title><meta name="twitter:title" content="Swift 프로그래밍 언어 - 문자열과 문자 | Optional Unwrapping"/><meta property="og:title" content="Swift 프로그래밍 언어 - 문자열과 문자 | Optional Unwrapping"/><meta name="description" content="Swift, iOS 개발하기"/><meta name="twitter:description" content="Swift, iOS 개발하기"/><meta property="og:description" content="Swift, iOS 개발하기"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Optional Unwrapping"/></head><head><link rel="stylesheet" href="/sundellsColors.css" type="text/css"/></head><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRTJYSRY7M"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-QRTJYSRY7M');</script></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Optional Unwrapping</a></div></header><div class="wrapper"><article><p>2015년 7월 7일</p><div class="content"><h1>Swift 스터디 1주차 (2015-07-04)</h1><p><strong>이 문서는 Apple의 <em>The Swift Programming Language (Swift 2 Prerelease)</em>의 요약입니다.</strong></p><h2>문자열과 문자(Strings and Characters)</h2><ul><li>Swift의 문자열은 <code>String</code> 타입으로 표현된다.</li><li><code>String</code> 타입은 <code>Character</code> 타입 값의 묶음이다.</li><li>Swift의 <code>String</code>과 <code>Character</code> 타입은 빠르고, 유니코드를 준수한다.</li><li>모든 문자열은 인코딩 독립적인 유니코드로 구성되고, 다양한 유니코드 표현법으로 접근할 수 있다.</li></ul><p>Swift의 <code>String</code> 타입은 <code>Foundation</code> 프레임워크의 <code>NSString</code> 클래스와 호환(bridged)된다. <code>Foundation</code> 프레임워크를 사용한다면 모든 <code>NSString</code> API를 <code>NSString</code>으로 타입 변환한 <code>String</code> 값에서 호출할 수 있다. 또한, 모든 <code>NSString</code> 인스턴스가 필요한 API에 <code>String</code> 값을 사용할 수 있다.</p><h3>문자열 리터럴</h3><ul><li>문자열 리터럴을 통해 <code>String</code> 값을 사용할 수 있다.</li><li>문자열 리터럴은 쌍따옴표로 둘러쌓인 연속된 문자이다.</li></ul><pre><code><span class="keyword">let</span> someString = <span class="string">"Some string literal value"</span>
</code></pre><h3>빈 문자열 만들기</h3><ul><li>빈 문자열 리터럴 또는 <code>String</code> 이니셜라이저 문법을 통해 빈 문자열을 만들 수 있다.</li></ul><pre><code><span class="keyword">var</span> emptyString = <span class="string">""</span>
<span class="keyword">var</span> anotherEmptyString = <span class="type">String</span>()
</code></pre><ul><li>두 방법의 결과는 동일하다.</li><li><code>isEmpty</code> 속성을 통해 <code>String</code> 값이 빈 문자열인지 확인할 수 있다.</li></ul><pre><code><span class="keyword">if</span> emptyString.<span class="property">isEmpty</span> {
    <span class="call">print</span>(<span class="string">"Nothing to see here"</span>)
}
</code></pre><h3>문자열 변수</h3><ul><li><code>String</code> 값을 변수 또는 상수로 할당할 수 있다.</li></ul><p>Objective-C를 쓰는 Cocoa와 다른 접근법이다.</p><h3>문자열은 값 타입이다</h3><ul><li>Swift의 <code>String</code> 타입은 값 타입이다.</li><li>새 <code>String</code> 값을 생성하면 함수 또는 메서드에 넘기거나 상수나 변수에 할당할 때 복사된 값을 넘긴다.</li></ul><p>Cocoa에서는 동일한 <code>NSString</code> 인스턴스를 참조한다.</p><ul><li>직접 변경하지 않은 이상 <code>String</code> 값이 변경되지 않았다고 확신할 수 있다.</li><li>Swift의 컴파일러는 반드시 복사가 필요할 때만 복사하도록 최적화한다. 이는 뛰어난 퍼포먼스를 의미한다.</li></ul><h3>문자 사용하기</h3><ul><li><code>for-in</code> 루프에 <code>String</code> 값의 <code>characters</code> 프로퍼티를 넣으면 각각의 <code>Character</code> 값에 접근할 수 있다.</li></ul><pre><code><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"Dog!🐶"</span>.<span class="property">characters</span> {
    <span class="call">print</span>(character)
}
</code></pre><ul><li>단일 문자 리터럴에 <code>Character</code> 타입 주석을 붙여서 독립적인 <code>Character</code> 상수나 변수를 만들 수 있다.</li><li><code>Character</code> 값의 배열을 <code>String</code> 값의 이니셜라이저 메서드에 넘겨서 <code>String</code> 값을 만들 수 있다.</li></ul><h3>문자열과 문자 결합하기</h3><ul><li><code>+</code> 연산자를 사용해서 문자열을 더한 새로운 <code>String</code> 값을 만들 수 있다.</li></ul><pre><code><span class="keyword">let</span> string1 = <span class="string">"hello"</span>
<span class="keyword">let</span> string2 = <span class="string">" there"</span>
<span class="keyword">var</span> welcome = string1 + string2
</code></pre><ul><li><code>+=</code> 연산자도 사용할 수 있다.</li><li><code>String</code> 타입의 <code>append()</code> 메서드를 사용해서 <code>Character</code> 값을 덧붙일 수 있다.</li></ul><p><code>String</code> 또는 <code>Character</code> 값을 <code>Character</code> 값에 덧불일 수 없다. <code>Character</code> 값은 하나의 문자만을 포함해야 하기 때문이다.</p><h3>문자열 삽입(interpolation)</h3><ul><li>문자열 삽입은 상수, 변수, 리터럴, 표현식이 섞여있는 문자열 리터럴에서 새로운 <code>String</code> 값을 만들어내는 방법이다.</li><li>문자열 리터럴에 백슬래시가 앞에 붙은 괄호로 둘러쌓인 값을 삽입한다.</li></ul><pre><code><span class="keyword">let</span> multiplier = <span class="number">3</span>
<span class="keyword">let</span> message = <span class="string">"</span>\(multiplier) <span class="string">times 2.5 is</span> \(<span class="type">Double</span>(multiplier) * <span class="number">2.5</span>)<span class="string">"</span>
</code></pre><p>괄호 안에 이스케이프되지 않은 쌍따옴표 또는 백슬래시 그리고 캐리지 리턴과 라인 피드는 포함하지 못한다.</p><h3>유니코드</h3><ul><li>유니코드는 다양한 쓰기 시스템에서 인코딩, 표시하기, 텍스트 처리를 하기 위한 국제 표준이다.</li><li>Swift의 <code>String</code>과 <code>Character</code> 타입은 완전히 유니코드를 따른다.</li></ul><h4>유니코드 스칼라</h4><ul><li>Swift의 <code>String</code> 타입은 유니코드 스칼라 값으로 만들어졌다.</li><li>유니코드 스칼라는 문자 또는 변경자를 위한 21비트 숫자이다.</li></ul><ul><li>모든 21비트 유니코드 스칼라에 문자가 할당되어 있지 않다. 일부는 나중을 위해 예약되어 있다.</li><li>스칼라에는 문자가 할당되어 있고 보통 <em>LATIN SMALL LETTER A</em> 같은 이름도 가지고 있다.</li></ul><h4>스트링 리터럴에서의 특별한 문자</h4><ul><li>스트링 리터럴은 다음의 특별한 문자를 포함할 수 있다.</li><li><code>\0</code>(널 문자), <code>\\</code>(백슬래시), <code>\t</code>(가로 탭), <code>\n</code>(라인 피드), <code>\r</code>(캐리지 리턴), <code>\"</code>(쌍따옴표), <code>\’</code>(홑따옴표)</li><li><code>\u{n}</code>로 쓰인 임의의 유니코드 스칼라. <em>n</em>은 유효한 유니코드 포인트와 같은 1-8자의 16진수.</li></ul><pre><code><span class="keyword">let</span> wiseWords = <span class="string">"\"Imagination is more important than knowledge\" - Einstein"</span>
<span class="comment">// "Imagination is more important than knowledge" - Einstein</span>
<span class="keyword">let</span> dollarSign = <span class="string">"\u{24}"</span>        <span class="comment">// $,  Unicode scalar U+0024</span>
<span class="keyword">let</span> blackHeart = <span class="string">"\u{2665}"</span>      <span class="comment">// ♥,  Unicode scalar U+2665</span>
<span class="keyword">let</span> sparklingHeart = <span class="string">"\u{1F496}"</span> <span class="comment">// 💖, Unicode scalar U+1F496</span>
</code></pre><h4>확장 자소 클러스터(Extended Grapheme Clusters)</h4><ul><li>모든 Swift의 <code>Character</code> 타입 인스턴스는 하나의 확장 자소 클러스터로 표현된다.</li><li>확장 자소 클러스터는 일련의 사람이 읽을 수 있는 문자(조합되었을 때)를 제공하는 하나 이상의 유니코드 스칼라이다.</li><li>예를 들어, <em>é</em>는 하나의 유니코드 스칼라로 표현된다(<em>LATIN SMALL LETTER E WITH ACUTE</em> 또는 <em>U+00E9</em>). 하지만 같은 문자를 <em>e</em>(<em>LATIN SMALL LETTER E</em> 또는 <em>U+0065</em>)와 뒤따르는 <em>COMBINING ACUTE ACCENT</em>(<em>U+0301</em>) 쌍으로 표현할 수 있다.</li><li>두 가지 경우 모두 하나의 <code>Character</code> 값으로 표현된다.</li></ul><pre><code><span class="keyword">let</span> eAcute: <span class="type">Character</span> = <span class="string">"\u{E9}"</span>                         <span class="comment">// é</span>
<span class="keyword">let</span> combinedEAcute: <span class="type">Character</span> = <span class="string">"\u{65}\u{301}"</span>          <span class="comment">// e followed by ́
// eAcute is é, combinedEAcute is é</span>
</code></pre><ul><li>확장 자소 클러스터는 조합 문자를 하나의 <code>Character</code> 값으로 표현한다. 예를 들어, 미리 조합된 문자와 분해된 문자 모두 하나의 <code>Character</code> 값으로 표현된다.</li></ul><pre><code><span class="keyword">let</span> precomposed: <span class="type">Character</span> = <span class="string">"\u{D55C}"</span>                  <span class="comment">// 한</span>
<span class="keyword">let</span> decomposed: <span class="type">Character</span> = <span class="string">"\u{1112}\u{1161}\u{11AB}"</span>   <span class="comment">// ᄒ, ᅡ, ᆫ
// precomposed is 한, decomposed is 한</span>
</code></pre><ul><li>확장 자소 클러스터는 스칼라를 감쌀 수도 있다.</li></ul><pre><code><span class="keyword">let</span> enclosedEAcute: <span class="type">Character</span> = <span class="string">"\u{E9}\u{20DD}"</span>
<span class="comment">// enclosedEAcute is é⃝</span>
</code></pre><ul><li>지역 표시 문자(regional indicator symbols)를 위한 유니코드 스칼라 한 쌍은 조합되어 하나의 <code>Character</code> 값을 만든다. <em>REGIONAL INDICATOR SYMBOL LETTER U</em>(<em>U+1F1FA</em>)와 <em>REGIONAL INDICATOR SYMBOL LETTER S</em>(<em>U+1F1F8</em>)</li></ul><pre><code><span class="keyword">let</span> regionalIndicatorForUS: <span class="type">Character</span> = <span class="string">"\u{1F1FA}\u{1F1F8}"</span>
<span class="comment">// regionalIndicatorForUS is 🇺🇸</span>
</code></pre><h3>문자 세기</h3><ul><li>문자열의 <code>Character</code> 값의 수를 얻기 위해 문자열의 <code>characters</code> 프로퍼티의 <code>count</code> 프로퍼티를 사용한다.</li></ul><pre><code><span class="keyword">let</span> unusualMenagerie = <span class="string">"Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"</span>
<span class="call">println</span>(<span class="string">"unusualMenagerie has</span> \(unusualMenagerie.<span class="property">characters</span>.<span class="property">count</span>) <span class="string">characters"</span>)
<span class="comment">// prints "unusualMenagerie has 40 characters"</span>
</code></pre><ul><li>Swift의 확장 자소 클러스터를 사용한 <code>Character</code> 값은 문자열 덧붙이기나 변경이 항상 문자열의 길이에 영향을 주지는 않는다는 것을 의미한다.</li><li>예를 들어, 4문자 단어 <em>cafe</em>에 <em>COMBINING ACUTE ACCECT</em>(<em>U+0301</em>)을 끝에 덧붙이면 문자 길이는 여전히 4이다.</li></ul><pre><code><span class="keyword">var</span> word = <span class="string">"cafe"</span>
<span class="call">println</span>(<span class="string">"the number of characters in</span> \(word) <span class="string">is</span> \(word.<span class="property">characters</span>.<span class="property">count</span>)<span class="string">"</span>)
<span class="comment">// prints "the number of characters in cafe is 4"</span>

word += <span class="string">"\u{301}"</span>    <span class="comment">// COMBINING ACUTE ACCENT, U+0301</span>

<span class="call">println</span>(<span class="string">"the number of characters in</span> \(word) <span class="string">is</span> \(word.<span class="property">characters</span>.<span class="property">count</span>)<span class="string">"</span>)
<span class="comment">// prints "the number of characters in café is 4"</span>
</code></pre><p>확장 자소 클러스터는 하나 이상의 유니코드 스칼라로 조합된다. 이는 같은 문자에 대한 다른 표현을 저장하기 위한 메모리 양이 다르다는 것을 의미한다.</p><p><code>characters</code> 프로퍼티와 <code>NSString</code>의 <code>length</code>와 항상 같지 않다.</p><h3>문자열 접근과 수정</h3><ul><li>문자열의 메서드와 프로퍼티 또는 서브스크립트 문법을 통해 문자열에 접근하고 수정한다.</li></ul><h4>문자열 인덱스</h4><ul><li>각각의 <code>String</code> 값은 포함하고 있는 각 <code>Character</code>의 위치를 가리키는 <code>String.Index</code> 타입을 가지고 있다.</li><li>앞서 언급한 것처럼 각 문자는 서로 다른 양의 메모리가 필요하다. 그래서 <code>Character</code>는 각자의 위치를 결정하기 위해 <code>String</code>의 처음부터 끝까지 반복해야 한다. 이런 이유로 Swift의 문자열은 정수로 색인되지 않는다.</li><li><code>startIndex</code> 프로퍼티는 <code>String</code>의 첫 번째 <code>Character</code>에 접근한다.</li><li><code>endIndex</code> 프로퍼티는 마지막 문자 다음을 반환한다.</li><li><code>String.Index</code> 값은 <code>predecessor()</code> 메서드를 호출해 직전 인덱스에 접근할 수 있고, <code>successor()</code> 메서드를 호출해 직후 인덱스에 접근할 수 있다.</li><li><code>String</code>의 모든 인덱스는 이들 메서드를 연결하거나 전역 함수 <code>advance(start:n:)</code>를 사용해서 접근할 수 있다.</li><li>문자열의 범위를 벗어난 인덱스에 접근하려고 시도하면 런타임 에러가 발생한다.</li><li><code>String</code>의 각 인덱스에 위치한 <code>Character</code>에 접근하기 위해 서브스크립트 문법을 사용할 수 있다.</li></ul><pre><code><span class="keyword">let</span> greeting = <span class="string">"Guten Tag"</span>
greeting[greeting.<span class="property">startIndex</span>]
<span class="comment">// G</span>
greeting[greeting.<span class="property">endIndex</span>.<span class="call">predecessor</span>()]
<span class="comment">// g</span>
greeting[greeting.<span class="property">startIndex</span>.<span class="call">successor</span>()]
<span class="comment">// u</span>
<span class="keyword">let</span> index = <span class="call">advance</span>(greeting.<span class="property">startIndex</span>, <span class="number">7</span>)
greeting[index]
<span class="comment">// a</span>
greeting[greeting.<span class="property">endIndex</span>] <span class="comment">// error</span>
greeting.<span class="property">endIndex</span>.<span class="call">successor</span>() <span class="comment">// error</span>
</code></pre><ul><li>문자열의 각각의 문자에 접근하기 위한 모든 인덱스의 <code>Range</code>를 만들기 위해 전역 함수 <code>indices(_:)</code>를 사용한다.</li></ul><pre><code><span class="keyword">for</span> index <span class="keyword">in</span> <span class="call">indices</span>(greeting) {
    <span class="call">print</span>(<span class="string">"</span>\(greeting[index])<span class="string">"</span>)
}
<span class="call">print</span>(<span class="string">"\n"</span>)
<span class="comment">// prints "Guten Tag"</span>
</code></pre><h4>삽입과 제거</h4><ul><li>문자열의 특정 인덱스에 문자를 삽입하기 위해, <code>insert(_:atIndex:)</code> 메서드를 사용한다.</li></ul><pre><code><span class="keyword">var</span> welcome = <span class="string">"hello"</span>
welcome.<span class="call">insert</span>(<span class="string">"!"</span>, atIndex: welcome.<span class="property">endIndex</span>)
<span class="comment">// welcome now equals "hello!"</span>
</code></pre><ul><li>다른 문자열을 특정 인덱스에 삽입하기 위해, <code>splice(_:atIndex:)</code> 메서드를 사용한다.</li></ul><pre><code>welcome.<span class="call">splice</span>(<span class="string">" there"</span>.<span class="property">characters</span>, atIndex: welcome.<span class="property">endIndex</span>.<span class="call">predecessor</span>())
<span class="comment">// welcome now equals "hello there!"</span>
</code></pre><ul><li>문자열에서 특정 인덱스의 문자를 제거하기 위해, <code>removeAtIndex(_:)</code> 메서드를 사용한다.</li></ul><pre><code>welcome.<span class="call">removeAtIndex</span>(welcome.<span class="property">endIndex</span>.<span class="call">predecessor</span>())
<span class="comment">// welcome now equals "hello there"</span>
</code></pre><ul><li>특정 범위의 문자열을 제거하기 위해, <code>removeRange(_:)</code> 메서드를 사용한다.</li></ul><pre><code><span class="keyword">let</span> range = <span class="call">advance</span>(welcome.<span class="property">endIndex</span>, -<span class="number">6</span>)..&lt;welcome.<span class="property">endIndex</span>
welcome.<span class="call">removeRange</span>(range)
<span class="comment">// welcome now equals "hello"</span>
</code></pre><h3>문자열 비교</h3><ul><li>Swift는 문자열과 문자 비교, 전위 비교, 후위 비교를 제공한다.</li></ul><h4>문자와 문자 동일성</h4><ul><li><code>==</code> 연산자와 <code>!=</code> 연산자로 동일성을 확인한다.</li></ul><ul><li>만약 두 <code>String</code> 값의 확장 문자 클러스터가 언어학적으로 같은 의미와 형태라면 같다고 간주한다.</li><li>반대로 영어에서 사용하는 <em>LATIN CAPITAL LETTER A</em>(<em>U+0041</em> 또는 <em>"A"</em>)와 러시아어에서 사용하는 <em>CYRILLIC CAPITAL LETTER A</em>(<em>U+0410</em> 또는 <em>"A"</em>)는 같지 않다.</li></ul><p>Swift의 문자열과 문자 비교는 로케일 무관하다.</p><h4>전위 후위 동일성</h4><ul><li>문자열의 <code>hasPrefix(_:)</code>와 <code>hasSuffix(_:)</code> 메서드를 호출해서 비교한다.</li></ul><h3>문자열의 유니코드 표현</h3><ul><li>유니코드 문자열이 텍스트 파일이나 다른 저장소에 쓰여질 때, 문자열의 유니코드 스칼라는 유니코드 정의 인코딩 양식 중 하나로 부호화된다.</li><li>각 양식은 <em>코드 유닛</em>으로 알려진 작은 단위로 문자열을 부호화한다.</li><li>이 양식은 UTF-8, UTF-16, UTF-32를 포함한다.</li></ul><ul><li>Swift는 문자열의 유니코드 표현에 접근하는 몇 가지 방법을 제공한다.</li><li><code>for-in</code> 문에서 반복을 통해 각 확장 자소 클러스터 <code>Character</code> 값에 접근할 수 있다.</li><li>다른 방법으로는 <code>String</code> 값의 세 프로퍼티 - <code>utf8</code>, <code>utf16</code>, <code>utf32</code>를 사용한다.</li></ul><h4>유니코드 스칼라 표현</h4><ul><li><code>String</code> 값의 <code>unicodeScalars</code> 프로퍼티를 반복해서, 유니코드 스칼라 표현에 접근할 수 있다.</li><li>이 프로퍼티의 타입인 <code>UnicodeScalarView</code>는 <code>UnicodeScalar</code>의 값의 묶음이다.</li><li>각 <code>UnicodeScalar</code>는 <code>UInt32</code> 값으로 표현되는 스칼라의 21비트 값을 반환하는 <code>value</code> 프로퍼티를 가지고 있다.</li></ul></div><ul class="tag-list"><li><a href="/tags/swift">Swift</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>